#Board Setup
#4x4 Sudoku
#[[?,?,?,4],[?,?,?,?],[2,?,?,3],[4,?,1,2]
import os
os.system('clear')

import pandas as pd
import math as math
import numpy as np

#Required functions
def poss_str_to_poss_lst(poss_string):
  import re
  poss_lst = []
  poss_string_split = poss_string.split(',')
  for i in poss_string_split:
    poss_lst.append(int(re.sub(r'[^0-9]', '', i)))
  return poss_lst

data = {
  "col1": [None,None,2,4],
  "col2": [None,None,None,None],
  "col3": [None,None,None,1],
  "col4": [4,None,3,2]
}

#load data into a DataFrame object:
df = pd.DataFrame(data)
print(df)

#Get shape of dataframe
shape = df.shape
#number of cols
print(shape[0])
#number of rows
print(shape[1])

#to reference an individual column, row, element in an array
row = df.iloc[:,3]
col = df.iloc[1,:]
element = df.iloc[2,2]

#Create a base possibiilities dataframe - mutliple possibilities need to be stored as a string
possibilities_df = df.astype(object)

NaNcount=0
lst = list(range(1,shape[0]+1))
for i in range(0,shape[0]):
  for j in range(0,shape[1]):
    if possibilities_df.iloc[i,j] == None or math.isnan(possibilities_df.iloc[i,j]) == True:
      NaNcount += 1
      possibilities_df.iloc[i,j] = str(lst)
    else:
      possibilities_df.iloc[i,j] = int(possibilities_df.iloc[i,j])
print(possibilities_df)
possibilities_df_orig = possibilities_df

#Overall looper, puzzle loops until is_done=1
is_done = 0
count=0

#os.system('clear')

while is_done == 0 and count <= 100:
  if count == 100:
    print('The puzzle has not been solved after 1000 loops')
    count += 1
  elif NaNcount == 0: 
    is_done=1
    print('The puzzle is done after',count,'loops')
  else:
    #Iterate across all cols
    #For each element, rule out potential possibiltiies if that possibility is already in row
    for i in range(0,shape[0]):
      for j in range(0,shape[1]):
        if type(possibilities_df.iloc[i,j]) is str:
          poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
          for x in possibilities_df.iloc[i,:]:
            if x in poss_lst:
              poss_lst.remove(x)
          for y in possibilities_df.iloc[:,j]:
            if y in poss_lst:
              poss_lst.remove(y)
          if len(poss_lst) == 1:
            possibilities_df.iloc[i,j] = int(poss_lst[0])
            NaNcount -= 1
          else:
            possibilities_df.iloc[i,j] = str(poss_lst)    
    #input additional logic to solve puzzle
    #incomplete_cells_count_all(df)
    count +=1

print(possibilities_df_orig)
#print(possibilities_df)