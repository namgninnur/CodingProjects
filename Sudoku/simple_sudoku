#Board Setup
#4x4 Sudoku
#[[?,?,?,4],[?,?,?,?],[2,?,?,3],[4,?,1,2]
import os
os.system('clear')

import pandas as pd
import math as math
import numpy as np

#Required functions
def poss_str_to_poss_lst(poss_string):
  import re
  poss_lst = []
  poss_string_split = poss_string.split(',')
  for i in poss_string_split:
    poss_lst.append(int(re.sub(r'[^0-9]', '', i)))
  return poss_lst

def box_picker(i,j,dim):
  if dim == 9:
    if i <=2:
      box = 0
    elif i > 2 and i <= 5:
      box = 3
    elif i > 5 and i <= 8:
      box = 6
    if j <=2:
      box += 1
    elif j > 2 and j <= 5:
      box += 2
    elif j > 5 and j <= 8:
      box += 3
  return box

def box_corner_row(box):
  if box <=3:
    box_corner_row = 0
  elif box >3 and box <=6:
    box_corner_row = 3
  elif box >6 and box <=9:
    box_corner_row = 6
  return box_corner_row

def box_corner_col(box):
  if box % 3 == 1:
    box_corner_col = 0
  elif box % 3 == 2:
    box_corner_col = 3
  elif box % 3 == 0:
    box_corner_col = 6
  return box_corner_col


#Data input template
#data = {
#  "col1": [None,],
#  "col2": [None,],
#  "col3": [None,],
#  "col4": [None,],
#  "col5": [None,],
#  "col6": [None,],
#  "col7": [None,],
#  "col8": [None,],
#  "col9": [None,]
#}

data1 = {
  "col1": [None,4,None,None,7,9,None,3,None],
  "col2": [None,None,6,8,None,None,5,2,None],
  "col3": [3,2,None,4,None,None,7,None,8],
  "col4": [7,None,None,None,8,None,3,None,1],
  "col5": [None,None,9,None,2,None,None,4,None],
  "col6": [None,None,8,6,1,5,None,None,9],
  "col7": [None,6,None,None,None,None,9,1,7],
  "col8": [1,8,4,None,9,2,6,5,None,],
  "col9": [5,None,None,None,None,3,4,None,None]
}
data = {
  "col1": [None,None,8,None,6,None,None,None,None],
  "col2": [9,None,None,8,None,None,None,7,6],
  "col3": [None,6,5,3,None,None,9,None,None],
  "col4": [8,5,None,None,None,3,6,None,None],
  "col5": [None,9,None,None,None,None,None,3,None],
  "col6": [None,None,6,1,None,None,None,5,7],
  "col7": [None,None,1,None,None,7,4,6,None],
  "col8": [2,4,None,None,None,1,None,None,3],
  "col9": [None,None,None,None,2,None,1,None,None]
}


#load data into a DataFrame object:
df = pd.DataFrame(data)
print(df)

#Get shape of dataframe
shape = df.shape
#number of cols
print(shape[0])
#number of rows
print(shape[1])

#to reference an individual column, row, element in an array
row = df.iloc[:,3]
col = df.iloc[1,:]
element = df.iloc[2,2]

#Create a base possibiilities dataframe - mutliple possibilities need to be stored as a string
possibilities_df = df.astype(object)

NaNcount=0
lst = list(range(1,shape[0]+1))
for i in range(0,shape[0]):
  for j in range(0,shape[1]):
    if possibilities_df.iloc[i,j] == None or math.isnan(possibilities_df.iloc[i,j]) == True:
      NaNcount += 1
      possibilities_df.iloc[i,j] = str(lst)
    else:
      possibilities_df.iloc[i,j] = int(possibilities_df.iloc[i,j])
print(possibilities_df)
possibilities_df_orig = possibilities_df

#Overall looper, puzzle loops until is_done=1
is_done = 0
count=0
count2=0

#os.system('clear')

while is_done == 0 and count <= 6:
  if count == 6:
    print('The puzzle has not been solved after 1000 loops')
    count += 1
  elif NaNcount == 0: 
    is_done=1
    print('The puzzle is done after',count,'loops')
  else:
    #For each element, rule out potential possibiltiies if that possibility is already in row/col
    for i in range(0,shape[0]):
      for j in range(0,shape[1]):
        if type(possibilities_df.iloc[i,j]) is str:
          poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
          for x in possibilities_df.iloc[i,:]:
            if x in poss_lst:
              poss_lst.remove(x)
          for y in possibilities_df.iloc[:,j]:
            if y in poss_lst:
              poss_lst.remove(y)
          
          box = box_picker(i,j,shape[0])
          #iterate for three elements of each of three rows (i.e. the box)
          for z in possibilities_df.iloc[box_corner_row(box):box_corner_row(box)+3,box_corner_col(box)]:
            if i == 0 and j == 0:
              print(possibilities_df.iloc[box_corner_row(box):box_corner_row(box)+3,box_corner_col(box):box_corner_col(box)+3])
              print('z is',z)
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          for z in possibilities_df.iloc[box_corner_row(box):box_corner_row(box)+3,box_corner_col(box)+1]:
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          for z in possibilities_df.iloc[box_corner_row(box):box_corner_row(box)+3,box_corner_col(box)+2]:
            if type(z) is int and z in poss_lst:
              poss_lst.remove(z)
          
          if len(poss_lst) == 1:
            if i == 0 and j == 0:
              print('look here')
            possibilities_df.iloc[i,j] = int(poss_lst[0])  
            NaNcount -= 1
            print(possibilities_df)
          else:
            possibilities_df.iloc[i,j] = str(poss_lst)
            if poss_lst ==[]:
              print('big problemmm')
                  
      #input additional logic to solve puzzle
      #e.g. examine lines and rows for only cell in that row/col/box that can be specific number
    
    #Examine each row to see if there are any numbers which can only go in one location
    for i in range(0,shape[0]):
      k_count=0
      for k in range(1,10):
        for j in range(0,shape[1]):
          if type(possibilities_df.iloc[i,j]) is str:
            #print('i is',i,'k is',k,'j is',j)
            #print(possibilities_df.iloc[i,j])
            poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
            if k in poss_lst:
              k_count += 1
        if k_count == 1:
          for j in range(0,shape[1]):
            if type(possibilities_df.iloc[i,j]) is str:
              poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
              if k in poss_lst:
                possibilities_df.iloc[i,j] = int(k)
                NaNcount -= 1
                print(possibilities_df)
    
    #Examine each col to see if there are any numbers which can only go in one location
    for j in range(0,shape[1]):
      k_count=0
      for k in range(1,10):
        for i in range(0,shape[0]):
          if type(possibilities_df.iloc[i,j]) is str:
            poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
            if k in poss_lst:
              k_count += 1
        if k_count == 1:
          for i in range(0,shape[0]):
            if type(possibilities_df.iloc[i,j]) is str:
              poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[i,j])
              if k in poss_lst:
                possibilities_df.iloc[i,j] = int(k)
                NaNcount -= 1
                print(possibilities_df)      
    #Examine each box to see if there are any numbers which can only go in one location
    for box in range(1,shape[0]+1):
    #box = 9
      for k in list(range(1,10)):
        k_count = 0
        for bx in range(0,3):
          for by in range(0,3):
            #print('box is',box,'k is',k,'bx is',bx,'by is',by)
            if type(possibilities_df.iloc[box_corner_row(box)+bx,box_corner_col(box)+by]) is str:
              poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[box_corner_row(box)+bx,box_corner_col(box)+by])
              #print(poss_lst)
              if k in poss_lst:
                k_count += 1
                #print('k_count is',k_count)
        if k_count == 1:
          for bx in range(0,3):
            for by in range(0,3):
              if type(possibilities_df.iloc[box_corner_row(box)+bx,box_corner_col(box)+by]) is str:
                poss_lst = poss_str_to_poss_lst(possibilities_df.iloc[box_corner_row(box)+bx,box_corner_col(box)+by])
                if k in poss_lst:
                  if box == 1 and bx == 0 and by == 0:
                    print(k)
                  possibilities_df.iloc[box_corner_row(box)+bx,box_corner_col(box)+by] = int(k)
                  NaNcount -= 1
                  print(possibilities_df)
    count +=1
    print(count)

#print(possibilities_df_orig)
print(possibilities_df)